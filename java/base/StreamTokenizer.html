<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (13.0.1) on Tue Feb 16 18:30:33 EST 2021 -->
<title>StreamTokenizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-02-16">
<meta name="description" content="declaration: package: java.base, class: StreamTokenizer">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">java.base</a></div>
<h1 title="Class StreamTokenizer" class="title">Class StreamTokenizer</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">java.base.StreamTokenizer</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="typeNameLabel">StreamTokenizer</span>
extends java.lang.Object</pre>
<div class="block">The <code>StreamTokenizer</code> class takes an input stream and
 parses it into "tokens", allowing the tokens to be
 read one at a time. The parsing process is controlled by a syntax tree
 and a number of flags that can be set to various states. The
 stream tokenizer can recognize identifiers, numbers, quoted
 strings, and various comment styles. A typical usecase is to
 first create an instance of this class, then modify the
 syntax tree (how the parser reacts to each character), and finally repeatedly loop calling the
 <code>nextToken</code> method in each iteration of the loop until
 it returns the value <code>TT_EOF</code>.
 <p>
 The syntax tree defines how the parser reacts to each character.
 Each ordinary character is seen as its own token.
 Consecutive word characters are grouped together into a single token.
 Numeric characters are grouped together into a single token. The values of 
 these tokens are stored in the fields <code>sval</code> and <code>nval</code> respectively.
 Whitespace characters seperate tokens such as word and number tokens.
 Comment characters sepcify the start of a single-line comment, which
 are ignored until the end of the line.
 Quote characters wrap string literals, which are seen as a single token and whose value is stored in <code>sval</code>.
 <p>
 default, the <code>StreamTokenizer</code> class's syntax tree recognizes
 <ul>
  <li> Word Characters as 'a-z' and 'A-Z' </li>
  <li> Numeric Characters as 0-9, "-", and "." </li>
  <li> Whitespace Characters as ASCII values from 0 to 32 </li>
  <li> Comment char as / </li>
  <li> Single Quote chars as \' and "
 </ul>
 </p>
 <p>
 If <code>st</code> is a <code>StreamTokenizer</code>, the default syntax tree is achieved by
 <blockquote><pre>st.wordChars('a', 'z');
        st.wordChars('A', 'Z');
        st.wordChars(128 + 32, 255);
        st.whitespaceChars(0, ' ');
        st.commentChar('/');
        st.quoteChar('"');
        st.quoteChar('\'');
        st.parseNumbers();
        </pre></blockquote>
 <p>
 To get started, here is an example provided by https://www.tutorialspoint.com/java/io/streamtokenizer_pushback.htm
 <blockquote><pre>import java.io.StreamTokenizer;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.BufferedReader;

class Tokenize {
    public static void main(String[] args) {
        String text = "Hello. This is a text \n that will be split " 
           + "into tokens. 1 + 1 = 2";
           
        try {
           // create a new file with an ObjectOutputStream
           FileOutputStream out = new FileOutputStream("test.txt");
           ObjectOutputStream oout = new ObjectOutputStream(out);
  
           // write something in the file
           oout.writeUTF(text);
           oout.flush();
  
           // create an ObjectInputStream for the file we created before
           ObjectInputStream ois = new ObjectInputStream(new FileInputStream("test.txt"));
  
           // create a new tokenizer
           Reader r = new BufferedReader(new InputStreamReader(ois));
           StreamTokenizer st = new StreamTokenizer(r);
  
           // specify that numbers should be parsed
           st.parseNumbers();
  
           // print the stream tokens
           boolean eof = false;
           
           do {
              int token = st.nextToken();
  
              switch (token) {
                 case StreamTokenizer.TT_EOF:
                    System.out.println("End of File encountered.");
                    eof = true;
                    break;
                    
                 case StreamTokenizer.TT_EOL:
                    System.out.println("End of Line encountered.");
                    break;
                    
                 case StreamTokenizer.TT_WORD:
                    System.out.println("Word: " + st.sval);
                    break;
                    
                 case StreamTokenizer.TT_NUMBER:
                    System.out.println("Number: " + st.nval);
                    break;
                    
                 default:
                    System.out.println((char) token + " encountered.");
                    
                    if (token == '!') {
                       eof = true;
                    }
              }
  
            } while (!eof);
  
        } catch (Exception ex) {
           ex.printStackTrace();
        }
    }
}</pre></blockquote>
 This is where we would put a state diagram, however we couldn't
 figure out how so it's in the other submission file.
 
 This class is <b>not thread safe</b>.</div>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nval">nval</a></span></code></th>
<td class="colLast">
<div class="block">If the last read token is a number, this fields contains the value 
 of that number.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sval">sval</a></span></code></th>
<td class="colLast">
<div class="block">If the last read token is a word, this field contains a string
 giving the characters of that word token.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#TT_EOF">TT_EOF</a></span></code></th>
<td class="colLast">
<div class="block">A constant indicating the end of the stream has been read.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#TT_EOL">TT_EOL</a></span></code></th>
<td class="colLast">
<div class="block">A constant indicating the end of a line has been read.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#TT_NUMBER">TT_NUMBER</a></span></code></th>
<td class="colLast">
<div class="block">A constant indicating a number token has been read.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#TT_WORD">TT_WORD</a></span></code></th>
<td class="colLast">
<div class="block">A constant indicating a word token has been read.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ttype">ttype</a></span></code></th>
<td class="colLast">
<div class="block">This field contains the type of the token most recently read by 
 a call to <code>nextToken</code>.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.io.InputStream)">StreamTokenizer</a></span>&#8203;(java.io.InputStream&nbsp;is)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Prefer creating <code>StreamTokenizer</code> with the <code>Reader</code></div>
</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.io.Reader)">StreamTokenizer</a></span>&#8203;(java.io.Reader&nbsp;r)</code></th>
<td class="colLast">
<div class="block">Creates a stream tokenizer to parse the given character stream.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#commentChar(int)">commentChar</a></span>&#8203;(int&nbsp;ch)</code></th>
<td class="colLast">
<div class="block">Specifies that the character argument starts a single-line
 comment.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#eolIsSignificant(boolean)">eolIsSignificant</a></span>&#8203;(boolean&nbsp;flag)</code></th>
<td class="colLast">
<div class="block">Determines if ends of line should be treated as tokens.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lineno()">lineno</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns current line number as long as the new line characters have not been modified by <code>ordinaryChar</code>.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#lowerCaseMode(boolean)">lowerCaseMode</a></span>&#8203;(boolean&nbsp;fl)</code></th>
<td class="colLast">
<div class="block">Determines if word tokens should be automatically lowercased in the <code>sval</code> field.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nextToken()">nextToken</a></span>()</code></th>
<td class="colLast">
<div class="block">Parses the next token from the input stream, returning the type of the token in the <code>ttype</code> field.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ordinaryChar(int)">ordinaryChar</a></span>&#8203;(int&nbsp;ch)</code></th>
<td class="colLast">
<div class="block">Specifies that the character argument is "ordinary"
 in this tokenizer.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ordinaryChars(int,int)">ordinaryChars</a></span>&#8203;(int&nbsp;low,
int&nbsp;hi)</code></th>
<td class="colLast">
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are "ordinary" in this tokenizer.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parseNumbers()">parseNumbers</a></span>()</code></th>
<td class="colLast">
<div class="block">Specifies that numbers should be parsed by this tokenizer.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pushBack()">pushBack</a></span>()</code></th>
<td class="colLast">
<div class="block">Causes the following call of the nextToken method of this tokenizer not increment to the next token and
 return ttype of the current token - all fields will remain the same.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#quoteChar(int)">quoteChar</a></span>&#8203;(int&nbsp;ch)</code></th>
<td class="colLast">
<div class="block">Specifies that matching pairs of this character delimit string
 constants in this tokenizer.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resetSyntax()">resetSyntax</a></span>()</code></th>
<td class="colLast">
<div class="block">Sets this tokenizer's syntax table so that all characters are
 "ordinary." Note this does not set the syntax table to the default
 outlined in the <code>StreamTokenizer</code> summary, as the default
 recognizes some characters as whitespace, comments, and numbers.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#slashSlashComments(boolean)">slashSlashComments</a></span>&#8203;(boolean&nbsp;flag)</code></th>
<td class="colLast">
<div class="block">Determines if the tokenizer recognizes C++-style comments.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#slashStarComments(boolean)">slashStarComments</a></span>&#8203;(boolean&nbsp;flag)</code></th>
<td class="colLast">
<div class="block">Determines if the tokenizer recognizes C-style.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a string representation of the current stream token and the line number it occurs on.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whitespaceChars(int,int)">whitespaceChars</a></span>&#8203;(int&nbsp;low,
int&nbsp;hi)</code></th>
<td class="colLast">
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are white space characters.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#wordChars(int,int)">wordChars</a></span>&#8203;(int&nbsp;low,
int&nbsp;hi)</code></th>
<td class="colLast">
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are word constituents.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="ttype">ttype</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">ttype</span></div>
<div class="block">This field contains the type of the token most recently read by 
 a call to <code>nextToken</code>. The value of this field will be
 <ul>
   <li><code>TT_WORD</code> if the last token was a word. </li>
   <li><code>TT_NUMBER</code> if the last token was a number. </li>
   <li><code>TT_EOL</code> if an end of line has been read (note this this field
        will only have this value if <code>eolIsSignficicant</code> has been called with
        <code>true</code> as the argument, otherwise end of lines will be ignored).</li>
   <li><code>TT_EOF</code> if the end of the input stream has been reached.</li>
   <li><i>ord(single character)</i> - if a single character has been read. For example 
   if <code>'+'</code> is read the value of <code>ttype</code> will be <code>43</code>. Note in the default configuration
   the standard 'abc...zAB...Z' will regarded as words, not characters. So if <code>'a'</code> is read the value
   of <code>ttype</code> will be <code>TT_WORD</code>.</li>
   <li><i>ord(quoteCharacter)</i> - if a quoted string is encountered. For example, in the default configuration,
   if <code>'T'</code> or <code>'ABCD'</code> are read, then value of <code>ttype</code> will be <code>39</code>.
 <ul></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="TT_EOF">TT_EOF</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">TT_EOF</span></div>
<div class="block">A constant indicating the end of the stream has been read.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#java.base.StreamTokenizer.TT_EOF">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="TT_EOL">TT_EOL</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">TT_EOL</span></div>
<div class="block">A constant indicating the end of a line has been read.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#java.base.StreamTokenizer.TT_EOL">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="TT_NUMBER">TT_NUMBER</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">TT_NUMBER</span></div>
<div class="block">A constant indicating a number token has been read.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#java.base.StreamTokenizer.TT_NUMBER">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="TT_WORD">TT_WORD</a></h3>
<div class="memberSignature"><span class="modifiers">public static final</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">TT_WORD</span></div>
<div class="block">A constant indicating a word token has been read.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#java.base.StreamTokenizer.TT_WORD">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="sval">sval</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">sval</span></div>
<div class="block">If the last read token is a word, this field contains a string
 giving the characters of that word token. If the last read token is a 
 quoted string token. the field contains the body of the string. If the method
 <code>lowerCaseMode</code> has been called with the argument <code>true</code>, then the string
 in this field will be lowercased. If the last token read is not a word token, the value of
 this field will be unchanged. The initial value of this field is <code>null</code>.
 <p>
 An example use of this field
 <code>
   if (st.ttype == TT_WORD) {
            System.out.println(st.sval);
        }
 </code></div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nval">nval</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">nval</span></div>
<div class="block">If the last read token is a number, this fields contains the value 
 of that number. By default the standard 0, 1, ..., 9, ., -, are parsed
 as numeric characters. The last read token is a number when the value
 of <code>ttype</code> is <code>TT_NUMBER</code>. The initial value of this field is <code>0.0</code>.
 <p>
 An example use of this field
 <code>
         if (st.ttype == TT_NUMBER) {
            System.out.println(st.nval + 10)
         }
 </code></div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(java.io.InputStream)">StreamTokenizer</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">StreamTokenizer</span>&#8203;(<span class="arguments">java.io.InputStream&nbsp;is)</span></div>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Prefer creating <code>StreamTokenizer</code> with the <code>Reader</code>
 <p> 
 An example instantiation if you have an input stream:
 <blockquote><pre>
 Reader r = new BufferedReader(new InputStreamReader(is));
   StreamTokenizer st = new StreamTokenizer(r);</pre></blockquote></div>
</div>
<div class="block">Creates a stream tokenizer that parses the given input stream.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>is</code> - an input stream</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer(Reader)</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(java.io.Reader)">StreamTokenizer</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">StreamTokenizer</span>&#8203;(<span class="arguments">java.io.Reader&nbsp;r)</span></div>
<div class="block">Creates a stream tokenizer to parse the given character stream. A typical 
 instantiation of this class
 <blockquote><pre>
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("inputFile.txt"));
        Reader r = new BufferedReader(new InputStreamReader(ois));
        StreamTokenizer st = new StreamTokenizer(r);</pre></blockquote>

 <p>
 The default synxtax is achieved by</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - is a Reader object providing the input stream for stream tokenizer to parse</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="resetSyntax()">resetSyntax</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">resetSyntax</span>()</div>
<div class="block">Sets this tokenizer's syntax table so that all characters are
 "ordinary." Note this does not set the syntax table to the default
 outlined in the <code>StreamTokenizer</code> summary, as the default
 recognizes some characters as whitespace, comments, and numbers.
 See the <code>ordinaryChar</code> method
 for more information on a character being ordinary.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.ordinaryChar(int)</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="wordChars(int,int)">wordChars</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">wordChars</span>&#8203;(<span class="arguments">int&nbsp;low,
int&nbsp;hi)</span></div>
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are word constituents. Consecutive word consitutents will be
 recognized as a single token. 

 <p>Any other attribute settings for the characters in the specified
 range are cleared.
 
 <p>
 For example, in the default configuration <code>"a", "b", "c", ..., "z", "A", ... "Z"</code> are 
 all word consitutents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>low</code> - the low end of the range.</dd>
<dd><code>hi</code> - the high end of the range.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="whitespaceChars(int,int)">whitespaceChars</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">whitespaceChars</span>&#8203;(<span class="arguments">int&nbsp;low,
int&nbsp;hi)</span></div>
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are white space characters. White space characters serve only to
 separate tokens in the input stream.

 <p>Any other attribute settings for the characters in the specified
 range are cleared.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>low</code> - the low end of the range.</dd>
<dd><code>hi</code> - the high end of the range.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="ordinaryChars(int,int)">ordinaryChars</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">ordinaryChars</span>&#8203;(<span class="arguments">int&nbsp;low,
int&nbsp;hi)</span></div>
<div class="block">Specifies that all characters <i>c</i> in the range
 <code>low &lt;= c &lt;= high</code>
 are "ordinary" in this tokenizer. See the
 <code>ordinaryChar</code> method for more information on a
 character being ordinary.

 <p>Any other attribute settings for the characters in the specified
 range are cleared.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>low</code> - the low end of the range.</dd>
<dd><code>hi</code> - the high end of the range.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.ordinaryChar(int)</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="ordinaryChar(int)">ordinaryChar</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">ordinaryChar</span>&#8203;(<span class="arguments">int&nbsp;ch)</span></div>
<div class="block">Specifies that the character argument is "ordinary"
 in this tokenizer. It removes any special significance the
 character has as a comment character, word component, string
 delimiter, white space, or number character. When such a character
 is encountered by the parser, the parser treats it as a
 single-character token and sets <code>ttype</code> field to the
 character value.

 <p>Making a line terminator character "ordinary" may interfere
 with the ability of a <code>StreamTokenizer</code> to count
 lines. The <code>lineno</code> method may no longer reflect
 the presence of such terminator characters in its line count.

 <p>Any other attribute settings for the specified character are cleared.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ch</code> - the character.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.ttype</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="commentChar(int)">commentChar</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">commentChar</span>&#8203;(<span class="arguments">int&nbsp;ch)</span></div>
<div class="block">Specifies that the character argument starts a single-line
 comment. All characters from the comment character to the end of
 the line are ignored by this stream tokenizer.

 <p>Any other attribute settings for the specified character are cleared.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ch</code> - the character.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="quoteChar(int)">quoteChar</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">quoteChar</span>&#8203;(<span class="arguments">int&nbsp;ch)</span></div>
<div class="block">Specifies that matching pairs of this character delimit string
 constants in this tokenizer.
 <p>
 When the <code>nextToken</code> method encounters a string
 constant, the <code>ttype</code> field is set to the string
 delimiter and the <code>sval</code> field is set to the body of
 the string.
 <p>
 If a string quote character is encountered, then a string is
 recognized, consisting of all characters after (but not including)
 the string quote character, up to (but not including) the next
 occurrence of that same string quote character, or a line
 terminator, or end of file. The usual escape sequences such as
 <code>"\n"</code> and <code>"\t"</code> are recognized and
 converted to single characters as the string is parsed.

 <p>Any other attribute settings for the specified character are cleared.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ch</code> - the character.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.nextToken()</code>, 
<code>StreamTokenizer.sval</code>, 
<code>StreamTokenizer.ttype</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="parseNumbers()">parseNumbers</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">parseNumbers</span>()</div>
<div class="block">Specifies that numbers should be parsed by this tokenizer. The
 syntax table of this tokenizer is modified so that each of the twelve
 characters:
 <blockquote><pre>
      0 1 2 3 4 5 6 7 8 9 . -
 </pre></blockquote>
 <p>
 has the "numeric" attribute. This is its default state.
 <p>
 When the parser encounters a word token that has the format of a
 double precision floating-point number, it treats the token as a
 number rather than a word, by setting the <code>ttype</code>
 field to the value <code>TT_NUMBER</code> and putting the numeric
 value of the token into the <code>nval</code> field.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.nval</code>, 
<code>StreamTokenizer.TT_NUMBER</code>, 
<code>StreamTokenizer.ttype</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="eolIsSignificant(boolean)">eolIsSignificant</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">eolIsSignificant</span>&#8203;(<span class="arguments">boolean&nbsp;flag)</span></div>
<div class="block">Determines if ends of line should be treated as tokens. By default ends of lines
 are not treated as tokens. If <code>eolIsSignificant</code> is called with the argument
 <code>true</code>, end of lines (<code>'\r'</code>, <code>'\n'</code>, <code>'\r\n'</code>) get treated
 as tokens and <code>nextToken</code> returns <code>TT_EOL</code> and <code>ttype</code> is set to <code>TT_EOL</code> when
 these tokens are read.
 <p>
 If <code>eolIsSignificant</code> is called with the argument <code>false</code>, ends of line are treated
 only as whitespace to separate tokens. 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>flag</code> - <code>true</code> indicates the end of line characters are their own separate token; <code>false</code> indicates
 end of line characters should just be treated as whitespace.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="slashStarComments(boolean)">slashStarComments</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">slashStarComments</span>&#8203;(<span class="arguments">boolean&nbsp;flag)</span></div>
<div class="block">Determines if the tokenizer recognizes C-style. By default the stream tokenizer does not
 recognize C-style comments. If <code>slashStarComments</code> is called with the argument <code>true</code>, then
 all text bettween <code>/*</code> and <code>*&#47;</code> is ignored.
 <p>
 For example if C-style comments are regonized on the string <code>"a /* bcdef</code> <code>*&#47</code> <code>g"</code> by
 a <code>StreamTokenizer st</code>, the first call to <code>st.nextToken()</code> will result in <code>st.sval == "a"</code> 
 and the second call will result in <code>st.sval == "g"</code>. 
 </p>
 <p>
 If <code>slashStartComments</code> is called with the argument <code>false</code>, then C-style slash star comments
 are not treated specially.
 </p>
 <p>
 Note: with the default configuration, '/' is a comment char so '/*' will ignore to end of line anyway, but 
 <code>*&#47;</code> will not stop the comment. Only a new line will.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>flag</code> - <code>true</code> indicates to recognize C-style comments. <code>false</code> indicates to not
 recognize C-style comments.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="slashSlashComments(boolean)">slashSlashComments</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">slashSlashComments</span>&#8203;(<span class="arguments">boolean&nbsp;flag)</span></div>
<div class="block">Determines if the tokenizer recognizes C++-style comments. By default the stream tokenizer does
 not recognize C++-style comments. If <code>slashSlashComments</code> is called with the argument <code>true</code>, then
 any two occurrences of the slash character (<code>'//''</code>) is treated as the beginning of a comment, and the stream
 is ignored until the next new line character. 
 <p>
 If <code>slashSlashComments</code> is called with the argument <code>false</code>, then C++-style comments are
 not treated specially.
 </p>
 <p>
 Note: in the default configuration, '/' is a comment char so '//' will be ignored anyway. Also calling
 <code>slashSlashComments(false)</code> will not change that '/' is a comment character. To do this you must call
 <code>resetSyntax</code> and choose a new comment character. However doing this will make all characters ordinary
 so then you must set your desired syntax.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>flag</code> - <code>true</code> indicates to recognize C++-style comments. <code>false</code> indicates to not
 recognize C++-style comments.
 </p></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="lowerCaseMode(boolean)">lowerCaseMode</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">lowerCaseMode</span>&#8203;(<span class="arguments">boolean&nbsp;fl)</span></div>
<div class="block">Determines if word tokens should be automatically lowercased in the <code>sval</code> field. 
 If <code>lowerCaseMode</code> is called with the argument <code>true</code>, then any subsequent
 calls to <code>nextToken</code> that parse a word token, will have the parsed result lowercased
 in <code>sval</code>.
 <p>
 If <code>lowerCaseMode</code> is called with the argument <code>false</code>, then after a word token is parsed, its
 value in <code>sval</code> is exactly the parsed value.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>flag</code> - <code>true</code> indicates that all word tokens should be lowercased. <code>false</code> indicates that 
 word tokens should remain as the parsed.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nextToken()">nextToken</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">nextToken</span>()
              throws <span class="exceptions">java.io.IOException</span></div>
<div class="block">Parses the next token from the input stream, returning the type of the token in the <code>ttype</code> field.
 More information about the return value of this function can be found in the <code>ttype</code> filed documentation.
 
 <p>
 A typical use of this of this function:
 <code>ObjectInputStream ois = new ObjectInputStream(new FileInputStream("inputFile.txt"));
        Reader r = new BufferedReader(new InputStreamReader(ois));
        StreamTokenizer st = new StreamTokenizer(r);</code>
        do {
           st.nextToken();
           // do something here with the st.ttype, st.nval, and st.sval fields
           if (st.ttype == TT_WORD) {
              System.out.println(st.sval) // prints the token if it was a word token
           }
        } while (st.ttype != TT_EOF)
      }</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the value of the <code>ttype field</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - if an I/O error occurs</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>StreamTokenizer.ttype</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="pushBack()">pushBack</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">pushBack</span>()</div>
<div class="block">Causes the following call of the nextToken method of this tokenizer not increment to the next token and
 return ttype of the current token - all fields will remain the same.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="lineno()">lineno</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">lineno</span>()</div>
<div class="block">Returns current line number as long as the new line characters have not been modified by <code>ordinaryChar</code>. 
 This method may not return the correct line number in the case <code>ordinaryChar</code> has made a line termination character "ordinary".</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current line number of the string tokenizer</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="toString()">toString</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">toString</span>()</div>
<div class="block">Returns a string representation of the current stream token and the line number it occurs on.
 There are a few possible formats for the return shape of the string based on <code>ttype</code> and the current line number. 
 Some typical examples include:
 <ul>
  <li>EOF - <code>Token[EOF], line 3</code> </li>
  <li>EOL - <code>Token[EOL], line 3</code></li>
  <li>Ordinay Char - <code>Token['+'], line 9</code></li>
  <li>Word - <code>Token[abc], line 5</code></li>
  <li>Number - <code>Token[n=123.456], line 2</code></li>
 </ul></div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
